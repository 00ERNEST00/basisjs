<?xml version="1.0" encoding="utf-8"?>

<!DOCTYPE HTML>

<html>

<head>
  <meta http-equiv="Content-type" content="text/html; charset=utf-8" />
  <title>Canvas</title>
  
  <script type="text/javascript" src="../src/basis.js"></script>
  <script type="text/javascript" src="../src/basis/data.js"></script>
  <script type="text/javascript" src="../src/basis/dom.js"></script>
  <script type="text/javascript" src="../src/basis/dom/wrapper.js"></script>
  <script type="text/javascript" src="../src/basis/entity.js"></script>
  <script type="text/javascript" src="../src/basis/ui/canvas.js"></script>
  <script type="text/javascript" src="../locale/ru/calendar.js"></script>

  <style type="text/css">
    CANVAS
    {
      b2ackground: #F0F0F0;
      b2order: 1px solid #E0E0E0;
    }
  </style>
</head>

<body>
  <script type="text/javascript">
    /*var graph = basis.ui.canvas.Shape.subclass({
      canHaveChildren: true,
      childClass: basis.dom.wrapper.AbstractNode,
      childFactory: function(c){
        return new this.childClass(c);
      },

      draw: function(context){
        var cnt = this.childNodes.length;

        if (!cnt)
          return;

        var w = context.canvas.width;
        var h = context.canvas.height;

        var H_PADDING = 20;
        var V_PADDING = 20;

        var step = (w - 2 * H_PADDING)/cnt;
        var x = H_PADDING;
        var node = this.firstChild;

        var max = 1.05 * Math.max.apply(null, this.childNodes.map(Function.getter('info.value')));

        context.save();
        context.strokeStyle = 'blue';
        context.lineWidth = 2.5;
        context.lineJoin = 'bevel';
        context.moveTo(x, V_PADDING + (h - 2 * V_PADDING) * (1-node.info.value/max));

        while (node = node.nextSibling)
          context.lineTo(x += step, V_PADDING + (h - 2 * V_PADDING) * (1-node.info.value/max));

        context.stroke();

        context.restore();          
      }
    });*/

    function getDegree(number){
      if (Math.abs(number) > 1)
      {
        return String(Math.floor(number)).length - 1;
      }
      else
      {
        /0\.(0+)?[^0]/.test(String(number));
        return (-1) * (RegExp.$1 || '').length - 1;
      }
    }

    /*var Point = basis.dom.wrapper.AbstractNode.subclass({
      className: 'GraphPoint',
      event_update: function(object, delta){
        if (this.parentNode)
          this.parentNode.updateCount += 1;

        basis.dom.wrapper.AbstractNode.prototype.event_update.call(this, object, delta);
      }
    });*/

    var AbstractNode = basis.dom.wrapper.AbstractNode;
    var Node = basis.dom.wrapper.Node;
    var Class = basis.Class;

    var GraphThread = Node.subclass({
      canHaveChildren: true,
      legendGetter: Function.getter('data.legend'),
      colorGetter: Function.getter('data.color'),
      valueGetterGetter: Function.getter('data.valueGetter'),

      getColor: function(){
        return this.color || this.colorGetter(this);
      },
      getLegend: function(){
        return this.legend || this.legendGetter(this)
      },
      getValueGetter: function(){
        return this.valueGetter || this.valueGetterGetter(this);
      },
      getValues: function(){
        return this.childNodes.map(this.getValueGetter());
      },

      childClass: {
        event_update: function(object, delta){
          if (this.parentNode && this.parentNode.parentNode)
            this.parentNode.parentNode.updateCount++; 

          AbstractNode.prototype.event_update.call(this, object, delta);
        }        
      },
      childFactory: function(config){
        return new this.childClass(config);
      }
    });

    var Canvas = basis.ui.canvas.Canvas;
    var Graph = Canvas.subclass({
      className: 'Graph',
      childClass: GraphThread,
      childFactory: function(config){
        if (config.delegate && config.delegate.data.dataSource)
          config.dataSource = config.delegate.data.dataSource;

        return new this.childClass(config);
      },

      //valueGetter: Function.getter('data.value'),
      propGetter: Function.getter('data.prop'),
      showLegend: true,
      
      event_childNodesModified: function(node, delta){
        this.updateCount++;
        Canvas.prototype.event_childNodesModified.call(this, node, delta);
      },
      event_localSortingChanged: function(node, oldLocalSorting, oldLocalSortingDesc){
        this.updateCount++;
        Canvas.prototype.event_localSortingChanged.call(this, node, oldLocalSorting, oldLocalSortingDesc);
      },

      style: {
        strokeStyle: '#090',
        lineWidth: 2.5,
        lineJoin: 'bevel'
      },

      threadColor: [
        '#6699DD',
        '#090'
      ],

      draw: function(){
        //this.updateCount++;
        Canvas.prototype.draw.call(this);
        //this.updateCount++;
        /*if (typeof aaa == 'undefined')
        {
          this.childNodes.forEach(function(v){
            v.update({ Amount: parseInt(Math.random() * 1000000) });
          });
        }/**/
      },
      drawFrame: function(){
        var propValues = this.getPropValues();

        if (!propValues.length)
          return;

        var context = this.context;

        var TOP = 10;
        var LEFT = 0;
        var RIGHT = 10;
        var BOTTOM = 0;
        var WIDTH = context.canvas.width;
        var HEIGHT = context.canvas.height;

        var minValue = this.getMinGridValue();
        var maxValue = this.getMaxGridValue();
        var partCount = this.getGridPartCount(minValue, maxValue); 


        //
        // calc yscale labels max width
        //
        var maxtw = 0;                            
        var y_labels = [];

        context.font = '10px tahoma';

        for (var i = 0; i < partCount; i++)
        {
          y_labels[i] = Math.round(maxValue * (partCount - i) / partCount).group();

          var tw = context.measureText(y_labels[i]).width;
          if (tw > maxtw)
            maxtw = tw;
        }
        
        LEFT =  maxtw + 6;

        var cnt = propValues.length + 1; 
        var step = (WIDTH - LEFT - RIGHT) / (cnt < 2 ? 1 : cnt) ;
        
        // Legend
        if (this.showLegend)
        {
          var LEGEND_ROW_HEIGHT = 30;
          var LEGEND_BAR_SIZE = 20;

          maxtw = 0;
          for (var i = 0, thread; thread = this.childNodes[i]; i++)
          {
            var tw = context.measureText(thread.getLegend()).width + LEGEND_BAR_SIZE + 20;
            if (tw > maxtw)
              maxtw = tw;
          }

          var legendColumnCount = Math.floor((WIDTH - LEFT - RIGHT) / maxtw);
          var legendColumnWidth = (WIDTH - LEFT - RIGHT) / legendColumnCount;
          var legendRowCount = Math.ceil(this.childNodes.length / legendColumnCount);

          //draw legend
          BOTTOM += LEGEND_ROW_HEIGHT * legendRowCount; // legend height

          for (var i = 0, thread; thread = this.childNodes[i]; i++)
          {
            var lx = LEFT + (i % legendColumnCount) * legendColumnWidth;
            var ly = HEIGHT - BOTTOM + 5 + (Math.ceil((i + 1) / legendColumnCount) - 1) * LEGEND_ROW_HEIGHT;

            context.fillStyle = thread.getColor() || this.threadColor[i];
            context.fillRect(lx, ly, LEGEND_BAR_SIZE, LEGEND_BAR_SIZE);

            context.fillStyle = 'black';
            context.textAlign = 'left';
            context.fillText(thread.getLegend(), lx + LEGEND_BAR_SIZE + 5, ly + LEGEND_BAR_SIZE / 2 + 3);
          }

          BOTTOM += 30; //legend margin-top;
        }


        // yscale
        context.lineWidth = 1;
        context.fillStyle = 'black';
        context.textAlign = 'right';
        var labelStep = (HEIGHT - TOP - BOTTOM) / partCount;
        for (var i = 0, label; label = y_labels[i]; i++)
        {
          var labelY = TOP + Math.round(i * labelStep) + .5;

          context.beginPath();
          context.moveTo(LEFT + .5, labelY);
          context.lineTo(WIDTH - RIGHT, labelY);
          context.strokeStyle = 'rgba(128, 128, 128, .25)';
          context.stroke();
          context.closePath();

          context.beginPath();
          context.moveTo(LEFT + .5 - 3, labelY);
          context.lineTo(LEFT + .5, labelY);
          context.strokeStyle = 'black';
          context.stroke();
          context.closePath();

          context.fillText(label, LEFT - 6, labelY + 2.5);
        }

        context.beginPath();
        context.moveTo(LEFT + .5, TOP);
        context.lineTo(LEFT + .5, HEIGHT - BOTTOM + .5);
        context.lineTo(WIDTH, HEIGHT - BOTTOM + .5);
        context.lineWidth = 1;
        context.strokeStyle = 'black';
        context.stroke();
        context.closePath();

        // xscale
        var lastLabelPos = 0;

        context.font = '9px tahoma';
        context.textAlign = 'center';

        context.beginPath();
        for (var i = 1; i < cnt; i++)
        {
          var x = Math.round(LEFT + i * step) + .5;

          var tw = context.measureText(propValues[i - 1]).width;
          if (lastLabelPos + 10 < (x - tw /2))
          {
            context.fillText(propValues[i - 1], x, HEIGHT - BOTTOM + 15);
            lastLabelPos = x + tw / 2;

            context.moveTo(x, HEIGHT - BOTTOM + .5);
            context.lineTo(x, HEIGHT - BOTTOM + 5);
          }
          else
          {
            context.moveTo(x, HEIGHT - BOTTOM + .5);
            context.lineTo(x, HEIGHT - BOTTOM + 3);
          }
        }
        context.lineWidth = 1;
        context.strokeStyle = 'black';
        context.stroke();
        context.closePath();

        
        // Threads
        var values;
        for (var i = 0, thread; thread = this.childNodes[i]; i++)
        {
          this.style.strokeStyle = thread.getColor() || this.threadColor[i];
          values = thread.getValues();
          this.drawThread(values, maxValue, LEFT + step, TOP, step, (HEIGHT - TOP - BOTTOM))
        }  
      },
      drawThread: function(values, max, left, top, step, height){
        var context = this.context;

        context.save();
        context.translate(left, top);
        context.beginPath();
        context.moveTo(0, height * (1 - values[0] / max));

        for (var i = 1; i < values.length; i++)
          context.lineTo(i * step, height * (1 - values[i] / max));

        Object.extend(context, this.style);
        context.stroke();
        context.closePath();
        context.restore();
      },
      getPropValues: function(){
        return (this.childNodes[0] && this.childNodes[0].childNodes.map(this.propGetter)) || [];
      },
      getMaxValue: function(){
        var values;
        var max = 0;
        
        for (var i = 0, thread; thread = this.childNodes[i]; i++)
        {
          values = thread.getValues();
          values.push(max);
          max = Math.max.apply(null, values);
        }

        return max;
      },
      getMinGridValue: function(){
        return 0;
      },
      getMaxGridValue: function(){
        var maxValue = this.getMaxValue();
        return Math.ceil(Math.round(maxValue) / Math.pow(10, getDegree(maxValue))) * Math.pow(10, getDegree(maxValue));
      },
      getGridPartCount: function(minValue, maxValue){
        var MIN_PART_COUNT = 5;
        var MAX_PART_COUNT = 20;

        var count = 1;
        var canDivide = true;
        var step;
        var divisionCount = 0;

        var maxDegree = getDegree(maxValue);

        while (count < MIN_PART_COUNT && divisionCount < maxDegree)
        {
          //canDivide = false;
          for (var i = 2; i <= 5; i++)
          {
            step = (maxValue - minValue) / i;
            newVal = (maxValue - step) / Math.pow(10, maxDegree - divisionCount);
            if ((newVal - Math.floor(newVal) == 0) && (count*i < MAX_PART_COUNT))
            {
              maxValue = minValue + step;
              count *= i;
              //canDivide = true;
              break;
            }
          } 

          divisionCount++;
        }

        return count;
      },
      setStyle: function(newStyle){
        Object.extend(this.style, Object.slice(newStyle, ['strokeStyle', 'lineWidth']));
        this.updateCount++;
      }
    });

    var Value = new basis.entity.EntityType({
      name: 'Value',
      fields: {
        Date: String,
        Count: Number,
        Amount: Number
      }
    });

    var Count = new basis.entity.EntityType({
      name: 'Count',
      fields: {
        Date: String,
        Value: Number
      }
    });

    var Amount = new basis.entity.EntityType({
      name: 'Amount',
      fields: {
        Date: String,
        Value: Number
      }
    });

    //for (var i = 0; i < 75; i++)
    //  Value({ Id: i, Value: parseInt(Math.random() * 50) });

    var data = [
      { Date: '2007-06', Count: 74, Amount: 1121994.63 },
      { Date: '2007-07', Count: 198, Amount: 70962.07 },
      { Date: '2007-08', Count: 327, Amount: 88081.64 },
      { Date: '2007-09', Count: 1435, Amount: 200698.7201 },
      { Date: '2007-10', Count: 2457, Amount: 355995.1301 },
      { Date: '2007-11', Count: 3120, Amount: 573421.2369 },
      { Date: '2007-12', Count: 5363, Amount: 1100866.1546 },
      { Date: '2008-01', Count: 11489, Amount: 2257144.699 },
      { Date: '2008-02', Count: 6303, Amount: 1471009.255 },
      { Date: '2008-03', Count: 5350, Amount: 1241891.353 },
      { Date: '2008-04', Count: 5774, Amount: 1862811.7237 },
      { Date: '2008-05', Count: 6995, Amount: 2390120.9235 },
      { Date: '2008-06', Count: 7294, Amount: 3256698.869 },
      { Date: '2008-07', Count: 6329, Amount: 2693387.0928 },
      { Date: '2008-08', Count: 7142, Amount: 3548683.748 },
      { Date: '2008-09', Count: 7810, Amount: 3880152.1971 },
      { Date: '2008-10', Count: 9862, Amount: 5666892.3515 },
      { Date: '2008-11', Count: 11221, Amount: 7444031.105 },
      { Date: '2008-12', Count: 14711, Amount: 9185893.4233 },
      { Date: '2009-01', Count: 13431, Amount: 7252555.3577 },
      { Date: '2009-02', Count: 12176, Amount: 6908588.6769 },
      { Date: '2009-03', Count: 12446, Amount: 7214006.0416 },
      { Date: '2009-04', Count: 12841, Amount: 6896383.4796 },
      { Date: '2009-05', Count: 13169, Amount: 7716787.7293 },
      { Date: '2009-06', Count: 13129, Amount: 7235950.6821 },
      { Date: '2009-07', Count: 13209, Amount: 7692433.0406 },
      { Date: '2009-08', Count: 14179, Amount: 7962404.4703 },
      { Date: '2009-09', Count: 15813, Amount: 9714701.8796 },
      { Date: '2009-10', Count: 15864, Amount: 9685311.0652 },
      { Date: '2009-11', Count: 15995, Amount: 9709073.3398 },
      { Date: '2009-12', Count: 18508, Amount: 12218506.7115 },
      { Date: '2010-01', Count: 18638, Amount: 10922637.8022 },
      { Date: '2010-02', Count: 18935, Amount: 12037523.1901 },
      { Date: '2010-03', Count: 27413, Amount: 14279206.1383 },
      { Date: '2010-04', Count: 25811, Amount: 13814033.711 },
      { Date: '2010-05', Count: 27830, Amount: 15885733.0432 },
      { Date: '2010-06', Count: 24076, Amount: 16612653.6971 },
      { Date: '2010-07', Count: 21680, Amount: 18416644.8046 },
      { Date: '2010-08', Count: 22715, Amount: 22899617.5211 },
      { Date: '2010-09', Count: 24833, Amount: 24641747.4133 }, /**/
      //{ Date: '2010-10', Count: 11337, Amount: 10062840.6528 }
    ].repeat(1);

    Value.all.sync(data);

    Count.all.sync(data.map(function(object){
      return {
        Date: object.Date,
        Value: object.Count
      }
    }));
    Amount.all.sync(data.map(function(object){
      return {
        Date: object.Date,
        Value: object.Amount
      }
    }));


    var threadDataSource = new basis.data.Dataset({});
    threadDataSource.set([
      {
        data: {
          dataSource: Value.all,
          valueGetter: Function.getter('data.Amount'),
          legend: 'Amount'
        }
      },
      {
        data: {
          dataSource: Value.all,
          valueGetter: Function.getter('data.Count'),
          legend: 'Count'
        }
      }
    ].map(function(object){ return new basis.data.DataObject(object) }))

    var threadDataSource2 = new basis.data.Dataset({});
    threadDataSource2.set([
      {
        data: {
          dataSource: Amount.all,
          valueGetter: Function.getter('data.Value'),
          legend: 'Сумма платежей'
        }
      },
      {
        data: {
          dataSource: Count.all,
          valueGetter: Function.getter('data.Value'),
          legend: 'Количество платежей'
        }
      }
    ].map(function(object){ return new basis.data.DataObject(object) }))

    var gg = new Graph({
      container: document.body,
      width: 800,
      height: 450,

      propGetter: function(object){
        var date = new Date(object.data.Date);
        return basis.locale['ui.calendar'].MONTH.SHORT[date.getMonth()].toLowerCase() + ' ' + date.getFullYear();
      },
      
      // 1. single thread
      /*childNodes: [
        {
          valueGetter: Function.getter('data.Amount'),
          legend: 'Amount',
          color: '#777',
          dataSource: Value.all,
          localSorting: Function.getter('data.Date')
        }
      ],/**/

      // 2. multi thread
      /*childNodes: [
        {
          valueGetter: Function.getter('data.Amount'),
          legend: 'Amount',
          color: '#777',
          dataSource: Value.all,
          localSorting: Function.getter('data.Date')
        },
        {
          valueGetter: Function.getter('data.Count'),
          legend: 'Count',
          color: '#0055FF',
          dataSource: Value.all,
          localSorting: Function.getter('data.Date')
        }
      ],/**/

      // 3. multi thread with dataSource control 
      dataSource: threadDataSource2,//threadDataSource,
      childClass: {
        localSorting: Function.getter('data.Date')
      }/**/
    });

    //document.body.appendChild(canvas.element);
    //canvas.draw();
  </script>
</body>

</html>